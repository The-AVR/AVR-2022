{% macro class(item, suffix) %}
class {{ item.name }}{{ suffix }}(TypedDict):
{%- if ('docs' in item and item['docs']|length > 0) or 'path' in item %}
    """
{%- if 'path' in item %}
    Topic: `{{ item.path }}`
{%- endif -%}
{%- if ('docs' in item and item['docs']|length > 0) %}
{%- if 'path' in item %}
{% endif %}
    {{ item.docs }}
{%- endif %}
    """
{% endif -%}
{%- if item.payload|length == 0 and ('docs' not in item or item['docs']|length == 0) %}
    pass
{%- else -%}
{%- for p in item.payload %}
    {{ p.key }}: {% if 'list' in p and p['list'] %}List[{{ p.type }}]{% else %}{{ p.type }}{% endif %}
{%- if 'docs' in p and p['docs']|length > 0 %}
    """
    {{ p.docs }}
    """
{%- endif %}
{%- endfor %}
{%- endif %}
{% endmacro -%}

# This file is automatically generated. DO NOT EDIT!
# fmt: off

from __future__ import annotations

import copy
import json
from typing import (
    Any,
    Dict,
    List,
    Literal,
    Optional,
    Protocol,
    Tuple,
    TypedDict,
    overload,
)

import paho.mqtt.client as mqtt
from loguru import logger

# ======== helper classes ========

{% for klass in klasses %}
{{ class(klass, "") }}
{% endfor %}
# =========== messages ===========

{% for topic in topics %}
{{ class(topic, "Message") }}
{% endfor %}

class MQTTMessageCache:
    def __init__(self) -> None:
        self.__storage = {}

{%- for topic in topics %}

    @overload
    def __getitem__(self, key: Literal["{{ topic.path }}"]) -> {{ topic.name }}Message: ...
{%- endfor %}

    def __getitem__(self, key: str) -> Any:
        return self.__storage.get(key, None)

    def __setitem__(self, key: str, value: Any) -> None:
        # not bothering with overloads here as no one should be setting
        # data in the cache other than us
        self.__storage[key] = value

    def __contains__(self, key: str) -> bool:
        return key in self.__storage


class MQTTCallable(Protocol):
    def __call__(self, payload: Any) -> Any:
        ...


class MQTTModule:
    """
    Generic MQTT Module class that should be inherited by other modules.
    `topic_prefix` should be a lowercase string that is the namespace
    for the class's MQTT messages. Additionally, the `topic_map` should
    be a dictionary of topics to functions that will be called with a dictionary
    payload.
    """

    def __init__(self, host="mqtt"):
        # these should be not be changed, to match the docker-compose.yml file
        self.mqtt_host = host
        self.mqtt_port = 18830

        # create the MQTT client
        self.mqtt_client = mqtt.Client()

        # set up the on connect and on message handlers
        self.mqtt_client.on_connect = self.on_connect
        self.mqtt_client.on_message = self.on_message

        # dictionary of MQTT topics to callback functions
        # this is intended to be overwritten by the child class
        self.topic_map: Dict[str, MQTTCallable] = {}

        # maintain a cache of the last message sent on a topic by this module
        self.message_cache = MQTTMessageCache()

    def run(self) -> None:
        """
        Class entrypoint. Connects to the MQTT broker and starts the MQTT loop
        in a blocking manner.
        """
        # connect the MQTT client
        self.mqtt_client.connect(host=self.mqtt_host, port=self.mqtt_port, keepalive=60)
        # run forever
        self.mqtt_client.loop_forever()

    def run_non_blocking(self) -> None:
        """
        Class entrypoint. Connects to the MQTT broker and starts the MQTT loop
        in a non-blocking manner.
        """
        # connect the MQTT client
        self.mqtt_client.connect(host=self.mqtt_host, port=self.mqtt_port, keepalive=60)
        # run in background
        self.mqtt_client.loop_start()

    def on_message(
        self, client: mqtt.Client, userdata: Any, msg: mqtt.MQTTMessage
    ) -> None:
        """
        On message callback, Dispatches the message to the appropriate function.
        """
        try:
            # logger.debug(f"Recieved {msg.topic}: {msg.payload}")
            if msg.topic in self.topic_map:
                # we talk JSON, no exceptions
                payload = json.loads(msg.payload)
                self.topic_map[msg.topic](payload)

        except Exception:
            logger.exception(f"Error handling message on {msg.topic}")

    def on_connect(
        self,
        client: mqtt.Client,
        userdata: Any,
        rc: Any,
        properties: Optional[mqtt.Properties] = None,
    ) -> None:
        """
        On connection callback. Subscribes to MQTT topics in the topic map.
        """
        logger.debug(f"Connected with result code {rc}")

        for topic in self.topic_map.keys():
            client.subscribe(topic)
            logger.success(f"Subscribed to: {topic}")

{%- for topic in topics %}

    @overload
    def send_message(self, topic: Literal["{{ topic.path }}"], payload: {{ topic.name }}Message) -> None: ...
{%- endfor %}

    def send_message(self, topic: str, payload: Any) -> None:
        """
        Sends a message to the MQTT broker.
        """
        # logger.debug(f"Sending message to {topic}: {payload}")
        self.mqtt_client.publish(topic, json.dumps(payload))
        self.message_cache[topic] = copy.deepcopy(payload)

