{% macro class(item, suffix) %}
class {{ item.name }}{{ suffix }}(TypedDict):
{%- if ('docs' in item and item['docs']|length > 0) %}
    """
    {{ item.docs }}
    """
{% endif -%}
{%- if item.payload|length == 0 and ('docs' not in item or item['docs']|length == 0) %}
    pass
{%- else -%}
{%- for p in item.payload %}
    {{ p.key }}: {% if 'list' in p and p['list'] %}List[{{ p.type }}]{% else %}{{ p.type }}{% endif %}
{%- if 'docs' in p and p['docs']|length > 0 %}
    """
    {{ p.docs }}
    """
{%- endif %}
{%- endfor %}
{%- endif %}
{% endmacro -%}

# This file is automatically generated. DO NOT EDIT!
# fmt: off

from __future__ import annotations

import copy
import json
from typing import (
    Any,
    List,
    Literal,
    Optional,
    Protocol,
    Tuple,
    TypedDict,
    Union,
    overload,
)

import paho.mqtt.client as mqtt
from loguru import logger

# ======== helper classes ========

{% for klass in klasses %}
{{ class(klass, "") }}
{% endfor %}
# =========== messages ===========

{% for topic in topics %}
{{ class(topic, "Message") }}

class _{{ topic.name }}Callable(Protocol):
    """
    Class used only for type-hinting MQTT callbacks
    """
    def __call__(self, payload: {{ topic.name }}Message) -> Any:
        ...

{% endfor %}

# create typed dict of callbacks associated with topics
_MQTTTopicMap = TypedDict("_MQTTTopicMap", {% raw %}{{% endraw %}{% for topic in topics %}"{{ topic.path }}": _{{ topic.name }}Callable, {% endfor %}{% raw %}}{% endraw %}, total=False)


class MQTTMessageCache:
    def __init__(self) -> None:
        self.__storage = {}

{%- for topic in topics %}

    @overload
    def __getitem__(self, key: Literal["{{ topic.path }}"]) -> Optional[{{ topic.name }}Message]: ...
{%- endfor %}

    def __getitem__(self, key: Literal[{% for topic in topics %}"{{ topic.path }}", {% endfor %}]) -> Union[None, {% for topic in topics %}{{ topic.name }}Message, {% endfor %}]:
        return self.__storage.get(key, None)

{%- for topic in topics %}

    @overload
    def __setitem__(self, key: Literal["{{ topic.path }}"], value: {{ topic.name }}Message) -> None: ...
{%- endfor %}

    def __setitem__(self, key: Literal[{% for topic in topics %}"{{ topic.path }}", {% endfor %}], value: Union[{% for topic in topics %}{{ topic.name }}Message, {% endfor %}]) -> None:
        self.__storage[key] = value

    def __contains__(self, key: str) -> bool:
        return key in self.__storage


class MQTTModule:
    """
    Generic MQTT Module class that should be inherited by other modules.
    The `topic_map` attribute should be a dictionary of topics to functions
    that will be called with a payload.
    """

    def __init__(self):
        # these should be not be changed
        self.mqtt_host = "mqtt"
        self.mqtt_port = 18830

        # create the MQTT client
        self._mqtt_client = mqtt.Client()

        # set up the on connect and on message handlers
        self._mqtt_client.on_connect = self.on_connect
        self._mqtt_client.on_message = self.on_message

        # dictionary of MQTT topics to callback functions
        # this is intended to be overwritten by the child class
        self.topic_map: _MQTTTopicMap = {}

        # maintain a cache of the last message sent on a topic by this module
        self.message_cache = MQTTMessageCache()

    def run(self) -> None:
        """
        Class entrypoint. Connects to the MQTT broker and starts the MQTT loop
        in a blocking manner.
        """
        # connect the MQTT client
        self._mqtt_client.connect(host=self.mqtt_host, port=self.mqtt_port, keepalive=60)
        # run forever
        self._mqtt_client.loop_forever()

    def run_non_blocking(self) -> None:
        """
        Class entrypoint. Connects to the MQTT broker and starts the MQTT loop
        in a non-blocking manner.
        """
        # connect the MQTT client
        self._mqtt_client.connect(host=self.mqtt_host, port=self.mqtt_port, keepalive=60)
        # run in background
        self._mqtt_client.loop_start()

    def on_message(
        self, client: mqtt.Client, userdata: Any, msg: mqtt.MQTTMessage
    ) -> None:
        """
        On message callback, Dispatches the message to the appropriate function.
        """
        try:
            # logger.debug(f"Recieved {msg.topic}: {msg.payload}")
            if msg.topic in self.topic_map:
                # we talk JSON, no exceptions
                payload = json.loads(msg.payload)
                self.topic_map[msg.topic](payload)

        except Exception:
            logger.exception(f"Error handling message on {msg.topic}")

    def on_connect(
        self,
        client: mqtt.Client,
        userdata: Any,
        rc: Any,
        properties: Optional[mqtt.Properties] = None,
    ) -> None:
        """
        On connection callback. Subscribes to MQTT topics in the topic map.
        """
        logger.debug(f"Connected with result {rc}")

        for topic in self.topic_map.keys():
            client.subscribe(topic)
            logger.success(f"Subscribed to: {topic}")

{%- for topic in topics %}

    @overload
    def send_message(self, topic: Literal["{{ topic.path }}"], payload: {{ topic.name }}Message) -> None: ...
{%- endfor %}

    def send_message(self, topic: Literal[{% for topic in topics %}"{{ topic.path }}", {% endfor %}], payload: Union[{% for topic in topics %}{{ topic.name }}Message, {% endfor %}]) -> None:
        """
        Sends a message to the MQTT broker.
        """
        # logger.debug(f"Sending message to {topic}: {payload}")
        self._mqtt_client.publish(topic, json.dumps(payload))
        self.message_cache[topic] = copy.deepcopy(payload)

